<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Solver (DFS)</title>
    <style>
      body {
        background: #0d1117;
        color: #fff;
        font-family: "Poppins", sans-serif;
        text-align: center;
      }

      h1 {
        margin-top: 10px;
        color: #58a6ff;
      }

      .buttons {
        margin: 10px;
      }

      button {
        margin: 5px;
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        background: #238636;
        color: white;
        cursor: pointer;
        font-size: 15px;
      }

      button:hover {
        background: #2ea043;
      }

      #maze {
        display: grid;
        justify-content: center;
        margin: 20px auto;
        grid-template-columns: repeat(30, 20px);
        grid-template-rows: repeat(30, 20px);
        gap: 1px;
      }

      .cell {
        width: 20px;
        height: 20px;
        background: #161b22;
        border-radius: 2px;
      }

      .wall {
        background: #30363d;
      }

      .start {
        background: #1f6feb;
      }

      .end {
        background: #f85149;
      }

      .visited {
        background: #d29922;
        transition: background 0.1s;
      }

      .path {
        background: #3fb950;
      }
    </style>
  </head>
  <body>
    <h1>Maze Solver (DFS)</h1>
    <div class="buttons">
      <button id="generateBtn">Generate Maze</button>
      <button id="solveBtn">Solve Maze (DFS)</button>
    </div>
    <div id="maze"></div>

    <script>
      const mazeContainer = document.getElementById("maze");
      const size = 30;
      let maze = [];
      let start = [0, 0];
      let end = [size - 1, size - 1];

      // Generate random maze
      function generateMaze() {
        mazeContainer.innerHTML = "";
        maze = Array.from({ length: size }, () =>
          Array.from({ length: size }, () => (Math.random() < 0.25 ? 1 : 0))
        );
        maze[0][0] = 0;
        maze[size - 1][size - 1] = 0;

        mazeContainer.style.gridTemplateColumns = `repeat(${size}, 20px)`;
        mazeContainer.style.gridTemplateRows = `repeat(${size}, 20px)`;

        for (let i = 0; i < size; i++) {
          for (let j = 0; j < size; j++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            if (maze[i][j] === 1) cell.classList.add("wall");
            if (i === 0 && j === 0) cell.classList.add("start");
            if (i === size - 1 && j === size - 1) cell.classList.add("end");
            mazeContainer.appendChild(cell);
          }
        }
      }

      async function solveMaze() {
        const visited = Array.from({ length: size }, () => Array(size).fill(false));
        const parent = Array.from({ length: size }, () => Array(size).fill(null));

        const found = await dfs(0, 0, visited, parent);

        if (found) {
          await drawPath(parent);
        } else {
          alert("No Path Found!");
        }
      }

      async function dfs(x, y, visited, parent) {
        if (x < 0 || y < 0 || x >= size || y >= size) return false;
        if (maze[x][y] === 1 || visited[x][y]) return false;

        visited[x][y] = true;

        const idx = x * size + y;
        const cell = mazeContainer.children[idx];
        if (!(x === 0 && y === 0)) {
          cell.classList.add("visited");
          await new Promise((res) => setTimeout(res, 20));
        }

        if (x === size - 1 && y === size - 1) return true;

        const dirs = [
          [1, 0],
          [0, 1],
          [-1, 0],
          [0, -1],
        ];

        for (let [dx, dy] of dirs) {
          const nx = x + dx,
            ny = y + dy;
          if (!visited[nx]?.[ny] && maze[nx]?.[ny] === 0) {
            parent[nx][ny] = [x, y];
            if (await dfs(nx, ny, visited, parent)) return true;
          }
        }

        return false;
      }

      async function drawPath(parent) {
        let [x, y] = [size - 1, size - 1];
        const path = [];

        while (x !== 0 || y !== 0) {
          path.push([x, y]);
          [x, y] = parent[x][y];
        }

        for (let [px, py] of path.reverse()) {
          const idx = px * size + py;
          const cell = mazeContainer.children[idx];
          cell.classList.add("path");
          await new Promise((res) => setTimeout(res, 30));
        }
      }

      document.getElementById("generateBtn").addEventListener("click", generateMaze);
      document.getElementById("solveBtn").addEventListener("click", solveMaze);

      generateMaze();
    </script>
  </body>
</html>
